<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Altitude AGL Temps Réel</title>
  <style>
    body {
      font-family: sans-serif;
      background: #111;
      color: #00f;
      text-align: center;
      padding: 1em;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      height: 100vh;
      transition: background 0.5s, color 0.5s;
    }
    #themeToggle, #sourceToggle, #recordToggle {
      position: absolute;
      background: #fff;
      color: #000;
      border: none;
      padding: 10px 15px;
      font-size: 1em;
      cursor: pointer;
      z-index: 1000;
      border-radius: 10px;
    }
    #themeToggle { top: 10px; left: 10px; }
    #sourceToggle { top: 10px; right: 10px; }
    #recordToggle { bottom: 10px; left: 10px; }
    #recordToggle.recording { background: red; color: #fff; }
    #agl {
      font-size: 3em;
      color: #0f0;
    }
    #agl small {
      font-size: 0.6em;
      vertical-align: super;
    }
    #asl, #terrain {
      font-size: 1em;
      margin-top: 1em;
      color: #00f;
    }
    .light-mode {
      background: #fff;
      color: #000;
    }
    .light-mode #agl {
      color: #000;
    }
    .light-mode #asl, .light-mode #terrain {
      color: #333;
    }
  </style>
</head>
<body>
  <button id="themeToggle">Mode clair</button>
  <button id="sourceToggle">Source: En ligne</button>
  <button id="recordToggle">Enregistrer</button>
  <div id="agl"><small>AGL:</small> <span id="agl-value">--</span> <small>m</small></div>
  <div id="asl">GPS Altitude: -- m</div>
  <div id="terrain">Sol: -- m</div>
  <script>
    let lastTerrain = null;
    let lastTerrainTime = 0;
    let asl = null;
    let lat = null;
    let lon = null;
    let heading = 0;
    let prevLat = null;
    let prevLon = null;
    let useOffline = false;
    let offlineData = null;
    let recording = false;
    let recordedPoints = [];

    async function loadOfflineData() {
      const res = await fetch("elevation_lac_labrie_30m.json");
      const json = await res.json();
      offlineData = json.data;
    }

    function toRad(deg) {
      return deg * Math.PI / 180;
    }

    function toDeg(rad) {
      return rad * 180 / Math.PI;
    }

    function computeHeading(lat1, lon1, lat2, lon2) {
      const dLon = toRad(lon2 - lon1);
      const y = Math.sin(dLon) * Math.cos(toRad(lat2));
      const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) - Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }

    function projectCoordinates(lat, lon, heading, distanceMeters) {
      const R = 6371000; // rayon Terre en m
      const d = distanceMeters;
      const brng = toRad(heading);
      const lat1 = toRad(lat);
      const lon1 = toRad(lon);

      const lat2 = Math.asin(Math.sin(lat1) * Math.cos(d / R) + Math.cos(lat1) * Math.sin(d / R) * Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng) * Math.sin(d / R) * Math.cos(lat1), Math.cos(d / R) - Math.sin(lat1) * Math.sin(lat2));

      return { lat: toDeg(lat2), lon: toDeg(lon2) };
    }

    function getOfflineElevation(lat, lon) {
      if (!offlineData) return null;

      const latFloor = Math.floor(lat * 100000) / 100000;
      const lonFloor = Math.floor(lon * 100000) / 100000;
      const latCeil = latFloor + 0.00001;
      const lonCeil = lonFloor + 0.00001;

      let q11, q21, q12, q22;
      for (const pt of offlineData) {
        if (pt.lat === latFloor && pt.lon === lonFloor) q11 = pt;
        if (pt.lat === latCeil && pt.lon === lonFloor) q21 = pt;
        if (pt.lat === latFloor && pt.lon === lonCeil) q12 = pt;
        if (pt.lat === latCeil && pt.lon === lonCeil) q22 = pt;
      }
      if (!(q11 && q21 && q12 && q22)) return null;

      const x = (lon - lonFloor) / (lonCeil - lonFloor);
      const y = (lat - latFloor) / (latCeil - latFloor);

      const r1 = q11.elevation * (1 - x) + q12.elevation * x;
      const r2 = q21.elevation * (1 - x) + q22.elevation * x;
      return r1 * (1 - y) + r2 * y;
    }

    async function updateTerrain(lat, lon, heading, speed) {
      const anticipation = Math.min(speed * 2, 150);
      const projected = projectCoordinates(lat, lon, heading, anticipation);
      const projLat = projected.lat;
      const projLon = projected.lon;

      if (useOffline) {
        lastTerrain = getOfflineElevation(projLat, projLon);
      } else {
        try {
          const res = await fetch(`https://api.opentopodata.org/v1/srtm90m?locations=${projLat},${projLon}`);
          const json = await res.json();
          lastTerrain = json.results[0].elevation;
        } catch (e) {
          console.error("Erreur fetch SRTM:", e);
          lastTerrain = null;
        }
      }
      lastTerrainTime = Date.now();
      updateDisplay();
    }

    function updateDisplay() {
      document.getElementById("asl").textContent = `GPS Altitude: ${asl?.toFixed(1) ?? '--'} m`;
      document.getElementById("terrain").textContent = `Sol: ${lastTerrain?.toFixed(1) ?? '--'} m`;
      if (asl !== null && lastTerrain !== null) {
        const agl = asl - lastTerrain;
        document.getElementById("agl-value").textContent = agl.toFixed(1);
        if (recording) {
          recordedPoints.push({ time: new Date().toISOString(), lat, lon, alt: asl });
        }
      } else {
        document.getElementById("agl-value").textContent = `--`;
      }
    }

    function watchPosition() {
      navigator.geolocation.watchPosition(pos => {
        prevLat = lat;
        prevLon = lon;
        lat = pos.coords.latitude;
        lon = pos.coords.longitude;
        asl = pos.coords.altitude ?? null;

        let speed = pos.coords.speed ?? 25;
        if (prevLat !== null && prevLon !== null) {
          heading = computeHeading(prevLat, prevLon, lat, lon);
        }

        updateTerrain(lat, lon, heading, speed);
      }, err => {
        console.error("Erreur GPS:", err);
      }, { enableHighAccuracy: true, maximumAge: 0, timeout: 5000 });
    }

    document.getElementById('themeToggle').addEventListener('click', () => {
      document.body.classList.toggle('light-mode');
      document.getElementById('themeToggle').textContent = document.body.classList.contains('light-mode') ? 'Mode sombre' : 'Mode clair';
    });

    document.getElementById('sourceToggle').addEventListener('click', () => {
      useOffline = !useOffline;
      document.getElementById('sourceToggle').textContent = `Source: ${useOffline ? 'Hors ligne' : 'En ligne'}`;
      if (lat && lon) updateTerrain(lat, lon, heading, 25);
    });

    document.getElementById('recordToggle').addEventListener('click', () => {
      recording = !recording;
      const btn = document.getElementById('recordToggle');
      btn.classList.toggle('recording', recording);
      btn.textContent = recording ? 'Arrêter' : 'Enregistrer';
      if (!recording && recordedPoints.length) {
        const kml = `<?xml version="1.0" encoding="UTF-8"?>\n<kml xmlns="http://www.opengis.net/kml/2.2">\n<Document>\n<name>Tracé AGL</name>\n<Placemark><LineString><altitudeMode>absolute</altitudeMode><coordinates>\n` +
          recordedPoints.map(p => `${p.lon},${p.lat},${p.alt}`).join(" ") +
          `\n</coordinates></LineString></Placemark>\n</Document></kml>`;
        const blob = new Blob([kml], { type: 'application/vnd.google-earth.kml+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = 'trace.kml';
        a.click();
        URL.revokeObjectURL(url);
        recordedPoints = [];
      }
    });

    let wakeLock = null;
    async function requestWakeLock() {
      try {
        if ('wakeLock' in navigator) {
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release', () => {
            console.log('Wake Lock was released');
          });
          console.log('Wake Lock is active');
        }
      } catch (err) {
        console.error(`${err.name}, ${err.message}`);
      }
    }
    document.addEventListener("visibilitychange", () => {
      if (wakeLock !== null && document.visibilityState === "visible") {
        requestWakeLock();
      }
    });

    setInterval(updateDisplay, 1500);
    loadOfflineData();
    watchPosition();
    requestWakeLock();
  </script>
</body>
</html>
